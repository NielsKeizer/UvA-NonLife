\documentclass[11pt]{article}

\usepackage[english]{babel}                 %% hyphenation rules, spell-checker
\usepackage{amsmath,amssymb}                        %% macros like align* and pmatrix
\usepackage{graphicx,epstopdf}              %% for .eps graphs
\usepackage[official]{eurosym}              %% 1 \euro
\usepackage[a4paper,margin=2cm]{geometry}   %% margins
\usepackage{nameref}
\usepackage{hyperref}                       %% hyperlinks to urls
\usepackage{float}                    

\frenchspacing                              %% no extra space after period
\addtolength{\parskip}{0.5\baselineskip}    %% some white space between paragraphs
\setlength{\parindent}{0pt}                 %% but no indentation
\renewcommand{\baselinestretch}{1.1}        %% line spacing of TeX is small
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\Cov}{\text{Cov}}


\title{Non-life --- Assignment NL4}  %% don't forget to change!

\author{
  Niels Keizer\footnote{Student number: 10910492}
  \quad and \quad
  Robert Jan Sopers\footnote{Student number: 0629049}
}

\date{\today}

\begin{document}

\maketitle

\section{De Vijlder's least squares method}


First we read in the data of \href{http://www1.fee.uva.nl/ke/act/people/kaas/DeVylder78.pdf}{De Vylder}.

\begin{verbatim}
rm(list=ls(all=TRUE)) ## Discard old garbage
Xij <- scan(n=60)
     0      0      0     0      0  4627
     0      0      0     0  15140 13343
     0      0      0 43465  19018 12476
     0      0 116531 42390  23505 14371
     0 346807 118035 43784  12750 12284
308580 407117 132247 37086  27744     0
358211 426329 157415 68219      0     0
327996 436744 147154     0      0     0
377369 561699      0     0      0     0
333827      0      0     0      0     0
\end{verbatim}

\subsection*{Q1}

We are asked to fill in the dots to create the covariates \verb|i| and \verb|j|. We use the folllowing statements in \verb|R|.

\begin{verbatim}
i <- rep(1:10, each=6) ## the row nrs are (1,1,1,1,1,1,2,2,2,2,2,2,...)
j <- rep(1:6,10)       ## the col nrs are (1,2,3,4,5,6,1,2,3,4,5,6,...)
k <- i+j-1             ## the calendar year of the payments
future <- which(k>10)  ## TRUE for obs with calendar year after now
valid <- which(Xij!=0) ## 1 for the non-zero obs, 0 for zero obs
\end{verbatim}

\subsection*{Q2}

We then run the code from the assignment to find the \verb|alpha| and \verb|beta| estimates.

\begin{verbatim}
fi <- as.factor(i); fj <- as.factor(j); fk <- as.factor(k)
xtabs(Xij~i+j)

start <- Xij+0.5
gg <- glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)

cc <- exp(coef(gg)); round(cc, 3)
alpha <- cc[1] * c(1,cc[2:10]); names(alpha)[1] <- "fi1"
beta <- c(1,cc[11:15]); names(beta)[1] <- "fj1"
alpha <- alpha * sum(beta); beta <- beta / sum(beta)
round(alpha); round(beta, 3)
\end{verbatim}

Then we check the obtained values against the values of $x_i$ and $p_i$ from \href{http://www1.fee.uva.nl/ke/act/people/kaas/DeVylder78.pdf}{De Vylder}, Table 3, p. 253.

\begin{verbatim}
> options(digits=2)
> beta
  fj1   fj2   fj3   fj4   fj5   fj6 
0.323 0.434 0.147 0.054 0.025 0.017 
> alpha
   fi1     fi2     fi3     fi4     fi5     fi6     fi7     fi8     fi9    fi10 
270638  664133  790749  796639  798643  939137 1032577 1009003 1249258 1033618
\end{verbatim}

We conclude that the values are almost exactly equal, with exception of \verb|fi10|, which has a value of $1033618$. where $x_9$ is $1033617$.

\subsection*{Q3}

We execute the code from the assignment and get the following:

\begin{verbatim}
> start <- rep(1,length(Xij))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
Error: no valid set of coefficients has been found: please supply starting values
> start <- rep(10000,length(Xij))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
Error: inner loop 1; cannot correct step size
In addition: Warning message:
step size truncated due to divergence 
> start <- rep(100000,length(Xij))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 9
> start <- rep(mean(Xij),length(Xij))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 10
> start <- rep(mean(Xij[Xij>0]), length(Xij))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 7
> start <- fitted.values(glm(Xij~fi+fj,poisson,weights=valid))
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 4
> start <- Xij+0.5
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 5
> start <- Xij; start[Xij==0] <- 0.01
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 5
> start <- pmax(Xij, 0.01)
> glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)$iter
[1] 5
\end{verbatim}

We see that starting with ones as values produces the same error as not supplying start values at all. Starting with values of $10000$ gives a divergence in the algorithm. Starting with values of $100000$ does not give divergence, but it does take 9 iterations. Starting with the mean of \verb|Xij| gives even more iterations, $10$, which is the highest for all glm's here. Initial values of the mean of the non zero values is slightly faster, but $7$ is still not as low as it can get. The lowest amount of iterations is obtained by starting with the coefficients of a glm that does allow for starting values $0$. The final three glm's all need 5 iterations. The final two even give exactly the same starting values and the one before that is comparable, as it adds $0.5$ to everything, thus preventing values equal to $0$.

\subsection*{Q4}

We generate a glm both without and with an inflation term and compare the results.

\begin{verbatim}
> gg <- glm(Xij~fi+fj,gaussian(link=log),weights=valid,mustart=start)
> ggg <- glm(Xij~fi+fj+k,gaussian(link=log),weights=valid,mustart=fitted(gg))
> round(exp(coef(gg)),3); round(exp(coef(ggg)),3)
(Intercept)         fi2         fi3         fi4         fi5         fi6         fi7         fi8 
  87407.917       2.454       2.922       2.944       2.951       3.470       3.815       3.728 
        fi9        fi10         fj2         fj3         fj4         fj5         fj6 
      4.616       3.819       1.344       0.455       0.168       0.077       0.053 
(Intercept)         fi2         fi3         fi4         fi5         fi6         fi7         fi8 
  87407.896       2.454       2.922       2.944       2.951       3.470       3.815       3.728 
        fi9        fi10         fj2         fj3         fj4         fj5         fj6           k 
      4.616       3.819       1.344       0.455       0.168       0.077       0.053          NA 
> gg$iter; ggg$iter
[1] 5
[1] 1
> (gg$deviance - ggg$deviance)/ggg$deviance
[1] 6.870721098e-14
\end{verbatim}

We find that the only difference is that the second glm reports that the coefficient for \verb|k| is \verb|NA|, which means that it did not need the variate. The second glm needed only one iteration to converge, which does not surprise us, seeing that its starting values are equal to the end result. The deviances are also pretty much the same. 

\subsection*{Q5}

We run the code from the assignment and get the following output in \verb|R|.

\begin{verbatim}
> xtabs(round(fitted(gg))*future~i+j)[6:10,2:6]
    j
i         2      3      4      5      6
  6       0      0      0      0  16056
  7       0      0      0  25666  17654
  8       0      0  54669  25080  17251
  9       0 183413  67686  31052  21358
  10 448672 151753  56003  25692  17671
\end{verbatim}

These results and those from Table 2 of \href{http://www1.fee.uva.nl/ke/act/people/kaas/DeVylder78.pdf}{De Vylder} are equal.

\subsection*{Q6}\label{ssec:q6}

The De Vijlder model is a multiplicative model $\alpha_{i}\beta_{j}$, which minimizes the least squares distance. Thus solving:

\begin{equation}\label{eqn:de_vijlder}
\min_{\alpha_{i},\beta_{j}} \sum_{i,j}w_{ij}\left(x_{ij} - \alpha_{i}\beta_{j}\right)^{2}
\end{equation}

We take the derivative of the sum with respect to $\alpha_{i'}$ and set it equal to zero.

\begin{eqnarray}
\frac{\partial}{\partial \alpha_{i'}} \sum_{i,j}w_{ij}\left(x_{ij} - \alpha_{i}\beta_{j}\right)^{2} &=& 0 \\
\sum_{i,j}w_{ij}\frac{\partial}{\partial \alpha_{i'}}\left(x_{ij} - \alpha_{i}\beta_{j}\right)^{2} &=& 0 \\
\sum_{i,j} w_{ij} \left(-2\beta_{j}\right) \left(x_{ij} - \alpha_{i}\beta_{j}\right) \delta_{i i'} &=& 0 \\
\sum_{j} w_{i'j} \left(-2\beta_{j}\right) \left(x_{i'j} - \alpha_{i'}\beta_{j}\right) &=& 0 \\
\alpha_{i} \sum_{j} w_{ij} \beta_{j}^{2} &=& \sum_{j} w_{ij}  x_{ij} \beta_{j}\\
\alpha_{i} &=& \frac{\sum_{j} w_{ij} x_{ij} \beta_{j}}{\sum_{j} w_{ij} \beta_{j}^{2}} \label{eqn:de_vijlder_result}
\end{eqnarray}

In the derivation above, we used that $ \frac{\partial \alpha_{i}}{\partial \alpha_{i'}} = \delta_{i i'} $, which is $1$ when $i = i'$, $0$ otherwise. Afterwards, we replaced $i'$ by $i$, for easier reading. Because equation \ref{eqn:de_vijlder} is symmetric in $\alpha_{i}$ and $\beta_{j}$, we can exchange them in equation \ref{eqn:de_vijlder_result} to obtain:

\begin{equation}
\beta_{j} = \frac{\sum_{i} w_{ij} x_{ij} \alpha_{i}}{\sum_{j} w_{ij} \alpha_{i}^{2}} 
\end{equation}

Using equation \ref{eqn:de_vijlder_result}, we fill the dots and run the following code, including results:

\begin{verbatim}
> beta <- rep(1, 6)
> repeat
+ { beta.old <- beta
+ alpha <- tapply(valid*Xij*beta[j],i,sum)/tapply(valid*beta[j]^2,i,sum)
+ beta <- tapply(valid*Xij*alpha[i],j,sum)/tapply(valid*alpha[i]^2,j,sum)
+ if (sum(abs((beta.old-beta)/beta)) < 1e-7) break ## out of the loop
+ # cat(beta,"\n") ## to monitor the iteration process
+ }
> round(xtabs(alpha[i]*beta[j]*future~i+j)[6:10,2:6])
    j
i         2      3      4      5      6
  6       0      0      0      0  16056
  7       0      0      0  25666  17654
  8       0      0  54669  25080  17251
  9       0 183413  67686  31052  21358
 10  448672 151753  56003  25692  17671
\end{verbatim}

These results are exactly the same as the one obtained from \nameref{ssec:q6}.

\section{Using Hoerl growth curves}

\subsection*{Q7}

To find for which $x$ the Hoerl-curve has a minimum, we differentiate $\beta(x)$ w.r.t. $x$ and set equal to zero.

\begin{eqnarray}
\frac{d}{dx} \exp(\gamma x + \delta \log(x)) &=& 0 \\
(\gamma + \frac{\delta}{x})\exp(\gamma x + \delta \log(x)) &=& 0 \\ 
(\gamma + \frac{\delta}{x}) &=& 0 \\
x &=& -\frac{\delta}{\gamma}
\end{eqnarray}

Because the logarithm only operates only strictly positive values, this means that there can only be a maximum when $\delta > 0$ and $\gamma < 0$. This result could also give a minimum, so we check if the second derivative is negative for this value of $x$. We get

\begin{eqnarray}
\frac{d^2}{dx^2} \exp(\gamma x + \delta \log(x)) &=& \frac{d}{dx} (\gamma + \frac{\delta}{x})\exp(\gamma x + \delta \log(x)) \\
&=& ((\gamma + \frac{\delta}{x})^{2} - \frac{\delta}{x^{2}}) \exp(\gamma x + \delta \log(x)) \\
&=& \frac{\delta}{(-\frac{\delta}{\gamma})^{2}} \exp(\gamma (-\frac{\delta}{\gamma}) + \delta \log(-\frac{\delta}{\gamma})) \\
&=& \frac{\gamma}{\delta} \exp(\delta( \log(-\frac{\delta}{\gamma})-1))
\end{eqnarray}

which is indeed a negative under the restrictions for $\delta$ and $\gamma$.

\begin{eqnarray}
\lim_{x \to \infty} \frac{\beta(x+1)}{\beta(x)} &=& \lim_{x \to \infty} \frac{\exp(\gamma (x+1) + \delta \log(x+1))}{\exp(\gamma x + \delta \log(x))} \\
&=& \lim_{x \to \infty}  \exp(\gamma + \delta(\log(x+1) - \log(x))) \\
&=& \lim_{x \to \infty}  \exp(\gamma + \delta\log\left(\frac{x+1}{x}\right)) \\
&=&\exp(\gamma + \delta\log\left(1\right)) \\
&=&\exp(\gamma) = d
\end{eqnarray}

\subsection*{Q8}

We fill the dots in the code and then check that \verb|beta[1]==1| holds.

\begin{verbatim}
> rm(list=ls(all=TRUE)) ## Discard old garbage
> TT <- 10; x.top <- 2; d <- .5
> gamma <- log(d); delta <- -x.top*gamma
> beta <- exp(gamma*(1:TT)+delta*log(1:TT))/exp(gamma)
> beta[1]==1
[1] TRUE
\end{verbatim}

\subsection*{Q9}

The \verb|Xij| values are all even numbers because the \verb|rpois| function only returns integers, after which they are multiplied by \verb|phi|, which is equal to two. An number is even when it is equal to an integer times two, therefore the \verb|Xij| values are all even.

\subsection*{Q10}

After running the code from the assignment several times, we find that the Hoerl model gets both accepted and rejected. We run this code:

\begin{verbatim}
 Xij <- phi * rpois(length(mu.ij), mu.ij/phi)
 
 xtabs(round(mu.ij)~i+j)
 round(xtabs(Xij~i+j))

 CL <- glm(Xij~fi+fj-1, quasipoisson)
 exp(coef(CL))
 
 Hoerl <- glm(Xij~fi+I(j-1)+log(j)-1, quasipoisson)
 
 round(coef(CL),3); round(coef(Hoerl),3)
 beta.CL <- exp(c(0,coef(CL)[(TT+1):(2*TT-1)]))
 beta.Hoerl <- exp(coef(Hoerl)[TT+1]*(0:(TT-1))) * (1:TT)^coef(Hoerl)[TT+2]
 round(rbind(beta.CL, beta.Hoerl), 4)
 plot(beta.CL); points
 
 scale <- CL$deviance/CL$df.residual
 Delta.Dev.Sc <- (Hoerl$deviance - CL$deviance)/scale
 Delta.df <- Hoerl$df.residual - CL$df.residual
 reject <- Delta.Dev.Sc > qchisq(0.95, Delta.df)
 cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
 "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
 "\nwith", Delta.df, "extra parameters.\n")
\end{verbatim}

And we get the following output:
\begin{verbatim}
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is not rejected since the scaled deviance gained by CL is 8.3 
with 7 extra parameters.
\end{verbatim}

\begin{verbatim}
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is rejected since the scaled deviance gained by CL is 16.3 
with 7 extra parameters.
\end{verbatim}

\begin{verbatim}
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is not rejected since the scaled deviance gained by CL is 9.4 
with 7 extra parameters.
\end{verbatim}

\begin{verbatim}
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is not rejected since the scaled deviance gained by CL is 5.8 
with 7 extra parameters.
\end{verbatim}

Out of a sample of $4$ iterations, the Hoerl model is rejected once.

\subsection*{Q11}
The CL-method is the fullest model available, therefore it is used to determine the scale factor. This is equal to the deviance divided by the residuals of the full CL-model. Because the Hoerl model uses less parameters, its deviance is likely to be larger, so the gain in deviance is that of the Hoerl model minus the CL-model. This is the divided by the scale factor to obtain the gain in scaled deviance. The difference in residuals is determined by subtracting the residuals of the models. The Hoerl model is then rejected when the gain in scaled deviance is larger than the $95$th percentile of a chi square distribution with the gain in residuals as degrees of freedom. This is exactly what the \verb|R| code does.

\subsection*{Q12}

We run similar code to the previous exercises:

\begin{verbatim}
> rm(list=ls(all=TRUE)) ## Discard old garbage
> Xij <- c(232,106,35,16,2, 258,115,56,27, 221,82,4, 359,71, 349)
>   i <- c( 1, 1, 1, 1,1, 2, 2, 2, 2, 3, 3,3, 4, 4, 5)
>   j <- c( 1, 2, 3, 4,5, 1, 2, 3, 4, 1, 2,3, 1, 2, 1)
> fi <- as.factor(i); fj <- as.factor(j)
> xtabs(Xij~i+j)
    j
i     1   2   3   4   5
  1 232 106  35  16   2
  2 258 115  56  27   0
  3 221  82   4   0   0
  4 359  71   0   0   0
  5 349   0   0   0   0
> CL <- glm(Xij~fi+fj-1, quasipoisson)
> Hoerl <- glm(Xij~fi+I(j-1)+log(j)-1, quasipoisson)
> # Then we do an anlysis of deviance.
> scale <- CL$deviance/CL$df.residual
> Delta.Dev.Sc <- (Hoerl$deviance - CL$deviance)/scale
> Delta.df <- Hoerl$df.residual - CL$df.residual
> reject <- Delta.Dev.Sc > qchisq(0.95, Delta.df)
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is not rejected since the scaled deviance gained by CL is 0.7 
with 2 extra parameters.
\end{verbatim}

The output is that the Hoerl model is not rejected, so it is a good fit to the $\beta$'s, compared to CL.

We also want to know if the portfolio growth can be described by a Hoerl curve. We then also try to fit a Hoerl curve to the rows.

\begin{verbatim}
> # Now try with a Hoerlcurve for the portfolio growth.
> Hoerl <- glm(Xij~I(i-1)+log(i)+fj-1, quasipoisson)
> # Then we do an anlysis of deviance.
> scale <- CL$deviance/CL$df.residual
> Delta.Dev.Sc <- (Hoerl$deviance - CL$deviance)/scale
> Delta.df <- Hoerl$df.residual - CL$df.residual
> reject <- Delta.Dev.Sc > qchisq(0.95, Delta.df)
> cat("The Hoerl model", ifelse(reject, "is", "is not"), "rejected",
+     "since the scaled deviance gained by CL is", round(Delta.Dev.Sc,1),
+     "\nwith", Delta.df, "extra parameters.\n")
The Hoerl model is not rejected since the scaled deviance gained by CL is 2.8 
with 2 extra parameters.
\end{verbatim}

We conclude that the CL model is not an improvement over the Hoerl model for the portfolio growth.

\end{document}
